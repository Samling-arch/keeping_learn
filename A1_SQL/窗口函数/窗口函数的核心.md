

# 5分钟学会SQL窗口函数 (超详细小白笔记)

> 这是一份写给0基础小白的SQL窗口函数入门指南。我们会从“为什么”开始，拆解每一个概念，并用最通俗的语言和最清晰的例子，让你彻底搞懂它。

### 核心概念总结表

| 核心概念               | 通俗解释                                             | 语法关键词                        |
| :----------------- | :----------------------------------------------- | :--------------------------- |
| **窗口函数**           | 在保持原有行数不变的前提下，进行分组、排序、计算。就像给数据开了一扇“窗户”看局部。       | `OVER()`                     |
| **分区 (Partition)** | “分组”，把数据切分成一个个独立的小组，窗口函数在每个小组内部分别计算。             | `PARTITION BY`               |
| **排序 (Order)**     | 在每个“小组”内部，按什么规则对数据进行排序。这对排名、计算前后行等至关重要。          | `ORDER BY`                   |
| **帧 (Frame)**      | 在排好序的“小组”内，进一步定义一个更小的计算范围，比如“当前行和它前面的两行”。        | `ROWS BETWEEN ... AND ...`   |
| **分析函数**           | 真正执行计算的函数，比如求和(`SUM`)、排名(`RANK`)、取上一行的值(`LAG`)等。 | `SUM()`, `RANK()`, `LAG()` 等 |

---

## # 1. 为什么需要窗口函数？ (Why Window Functions?)

> **一句话概括：** 它能让你在分组后，还能对组里的每一行数据进行计算和排序，这是普通`GROUP BY`做不到的。

我们先来看一个问题。假设我们有一张**员工销售表 (`sales`)**：

| 员工 (employee) | 部门 (department) | 销售额 (amount) |
| :--- | :--- | :--- |
| 张三 | 销售A部 | 8000 |
| 李四 | 销售A部 | 10000 |
| 王五 | 销售B部 | 9000 |
| 赵六 | 销售B部 | 12000 |
| 孙七 | 销售A部 | 8000 |

**需求：** 我想知道每个部门的总销售额，*同时*还想看每个员工自己的销售额。

如果用我们熟悉的 `GROUP BY`：
```sql
SELECT
    department,
    SUM(amount) AS department_total
FROM sales
GROUP BY department;
```
你会得到：

| department | department_total |
| :--- | :--- |
| 销售A部 | 26000 |
| 销售B部 | 21000 |

看到了吗？`GROUP BY` 把原始的行都“压扁”了，我们丢失了张三、李四等人的个人销售额信息。

**窗口函数的出现就是为了解决这个问题！** 它允许你在计算“部门总销售额”的同时，保留每一行的原始数据。它就像一个加强版的 `GROUP BY`。

玄米4S视频里提到，窗口函数有点像编程里的 `for` 循环，这个比喻很形象。它会“遍历”你指定的数据范围（窗口），对每一行都进行一次计算，但不会把行合并。

## # 2. 窗口函数的核心语法 (Core Syntax)

> **一句话概括：** 记住这个公式模板，所有窗口函数都长这个样。

一个完整的窗口函数语法结构如下，你现在可能看不懂，没关系，我们会逐一拆解。
00
$$
分析函数() OVER (
    PARTITION BY <用来分区的列名>
    ORDER BY <用来排序的列名>
    ROWS BETWEEN <帧的开始位置> AND <帧的结束位置>
)
$$

- **`分析函数()`**: 你想干什么？（求和、排名...）
- **`OVER (...)`**: 告诉SQL：“我要开窗了！”。括号里面是开窗的规则。
- **`PARTITION BY`**: 怎么分组？（可选）
- **`ORDER BY`**: 组内怎么排？（可选，但对很多函数是必需的）
- **`ROWS BETWEEN ...`**: 在组内，具体计算哪几行？（可选）

---

### ## 2.1 分析函数() - 你想干什么？

> **一句话概括：** 这是具体要执行的计算，比如求和、计数，或者给个排名。

这些函数本身你可能已经见过，但只有和 `OVER()` 结合使用时，它们才成为窗口函数。
- **聚合函数**: `SUM()`(求和), `AVG()`(平均), `COUNT()`(计数), `MAX()`(最大), `MIN()`(最小)。
- **排名函数**: `ROW_NUMBER()`(行号), `RANK()`(排名,有并列), `DENSE_RANK()`(密集排名,无间断)。
- **偏移函数**: `LAG()`(取前N行的数据), `LEAD()`(取后N行的数据)。

### ## 2.2 `OVER()` - 开窗！

> **一句话概括：** 这个关键字是窗口函数的“身份证”，告诉SQL：“注意！接下来是个窗口函数，不是普通函数！”

所有窗口规则都写在 `OVER()` 的括号里。如果括号里什么都不写，比如 `SUM(amount) OVER ()`，那么窗口就是**整个表**。它会计算整个表的总销售额，并把这个值赋给每一行。

### ## 2.3 `PARTITION BY <分区列>` - 怎么分组？

> **一句话概括：** 按什么条件把数据切成一小块一小块的“窗户”，比如按“部门”分区。

`PARTITION BY` 非常像 `GROUP BY`，但它只做分组，**不合并行**。

**例子：** 计算每个部门的销售总额，但保留每个员工的记录。

```sql
SELECT
    employee,
    department,
    amount,
    SUM(amount) OVER (PARTITION BY department) AS department_total
FROM sales;
```

**结果：**

| employee | department | amount | department_total |
| :------- | :--------- | :----- | :--------------- |
| 张三       | 销售A部       | 8000   | **26000**        |
| 李四       | 销售A部       | 10000  | **26000**        |
| 孙七       | 销售A部       | 8000   | **26000**        |
| 王五       | 销售B部       | 9000   | **21000**        |
| 赵六       | 销售B部       | 12000  | **21000**        |

**来源和细节：**
- `PARTITION BY department` 把数据分成了“销售A部”和“销售B部”两个独立的窗口。
- 对于“销售A部”窗口里的每一行（张三、李四、孙七），`SUM(amount)` 计算的都是这个窗口的总和 ($8000 + 10000 + 8000 = 26000$)。
- 对于“销售B部”窗口里的每一行（王五、赵六），`SUM(amount)` 计算的也是这个窗口的总和 ($9000 + 12000 = 21000$)。
- 原始的 $5$ 行数据被完整地保留了下来。

### ## 2.4 `ORDER BY <排序列>` - 组内怎么排？

> **一句话概括：** 组分好了，组内的数据按什么顺序排列？比如按销售额从高到低排。

`ORDER BY` 在窗口函数内部，决定了函数计算的“顺序”。这对于排名、累计计算等场景至关重要。

**例子：** 我们想计算每个员工的“累计销售额”（Running Total）。比如，按时间顺序，第一个月的累计就是第一个月的，第二个月的累计是第一和第二个月之和。

假设我们的表现在有日期：

| employee | sale_month | amount |
| :--- | :--- | :--- |
| 张三 | 1 | 3000 |
| 张三 | 2 | 4000 |
| 张三 | 3 | 2000 |

```sql
SELECT
    employee,
    sale_month,
    amount,
    SUM(amount) OVER (PARTITION BY employee ORDER BY sale_month) AS running_total
FROM sales_by_month;
```
**结果：**

| employee | sale_month | amount | running_total |
| :--- | :--- | :--- | :--- |
| 张三 | 1 | 3000 | **3000** |
| 张三 | 2 | 4000 | **7000** |
| 张三 | 3 | 2000 | **9000** |

**来源和细节：**
- `ORDER BY sale_month` 告诉SQL在“张三”这个分区内，要按月份从小到大排序。
- **第1行 (月份1):** 窗口内计算范围是“从开头到当前行”，所以 `SUM` 是 $3000$。
- **第2行 (月份2):** 窗口内计算范围是“从开头到当前行(月份2)”，所以 `SUM` 是 $3000 + 4000 = 7000$。
- **第3行 (月份3):** 窗口内计算范围是“从开头到当前行(月份3)”，所以 `SUM` 是 $3000 + 4000 + 2000 = 9000$。

### ## 2.5 `ROWS BETWEEN ...` - 定义计算的“帧”

> **一句话概括：** 在排好序的组内，具体要计算哪几行？是计算从第一行到当前行，还是只计算前后几行？

这是最精细的控制，我们称之为“帧”（Frame）。默认情况下（当你只写 `ORDER BY` 时），帧就是 `ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW`（从分区起点到当前行）。

**常用关键字：**
- `CURRENT ROW`: 当前行
- `n PRECEDING`: 往前 $n$ 行
- `n FOLLOWING`: 往后 $n$ 行
- `UNBOUNDED PRECEDING`: 分区的最开始（无边界的之前），也就是起点。
- `UNBOUNDED FOLLOWING`: 分区的最末尾（无边界的之后），也就是终点。

**例子1：从起点到当前行 (和上面累计求和效果一样)**
> 这是计算累计值的标准写法。

$$
ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW
$$
这个表达式的意思是：计算范围从分区的第一行，一直到我目前所在的这一行。

**例子2：当前行、往前 $2$ 行、往后 $1$ 行**
> 这是一个“滑动窗口”，窗口大小始终是 $4$ 行（$2+1+1$）。

$$
ROWS BETWEEN 2 PRECEDING AND 1 FOLLOWING
$$
这个表达式的意思是：计算范围包括我前面的 $2$ 行、我自己这行、还有我后面的 $1$ 行。

---

## # 3. 常用分析函数实战 (Practical Examples)

我们用回最开始的员工销售表，并按部门内销售额降序排名。

**准备数据：**
```sql
-- 想象我们有这样一张表 `sales`
-- employee, department, amount
-- '张三', '销售A部', 8000
-- '李四', '销售A部', 10000
-- '王五', '销售B部', 9000
-- '赵六', '销售B部', 12000
-- '孙七', '销售A部', 8000
```

### ## 3.1 排名函数：`ROW_NUMBER()`, `RANK()`, `DENSE_RANK()`

> **一句话概括：** 给每个部门的员工业绩排个名次。

**需求：** 对每个部门的员工按销售额进行排名。

```sql
SELECT
    employee,
    department,
    amount,
    ROW_NUMBER() OVER (PARTITION BY department ORDER BY amount DESC) AS row_num_rank,
    RANK()       OVER (PARTITION BY department ORDER BY amount DESC) AS rank_rank,
    DENSE_RANK() OVER (PARTITION BY department ORDER BY amount DESC) AS dense_rank_rank
FROM sales;
```

**结果：**

| employee | department | amount | row_num_rank | rank_rank | dense_rank_rank |
| :--- | :--- | :--- | :--- | :--- | :--- |
| 李四 | 销售A部 | 10000 | 1 | 1 | 1 |
| 张三 | 销售A部 | 8000 | 2 | 2 | 2 |
| 孙七 | 销售A部 | 8000 | 3 | 2 | 2 |
| 赵六 | 销售B部 | 12000 | 1 | 1 | 1 |
| 王五 | 销售B部 | 9000 | 2 | 2 | 2 |

**来源和细节（重点看销售A部）：**
- `PARTITION BY department` 将数据分为 A、B 两个区。
- `ORDER BY amount DESC` 在每个区内按销售额从高到低排序。
- **`ROW_NUMBER()`**: 铁面无私的行号。不管值是否相同，就是 $1, 2, 3...$ 排下去。
- **`RANK()`**: 并列排名，会“跳号”。张三和孙七销售额相同，都是第 $2$ 名。因为他们占了第 $2$ 和第 $3$ 两个位置，所以下一个名次直接从 $4$ 开始（如果还有人的话）。这就是“跳号”。
- **`DENSE_RANK()`**: 密集的并列排名，不“跳号”。张三和孙七并列第 $2$ 名后，下一个名次紧接着是 $3$。这就是视频里提到的 `DENSE` 的含义，它是连续的。

### ## 3.2 偏移函数：`LAG()` 和 `LEAD()`

> **一句话概括：** 轻松获取上一行或下一行的数据，比如计算和排名第一的差距。

- `LAG(列名, n, 默认值)`: 获取当前行往前第 $n$ 行的 `列名` 的值。
- `LEAD(列名, n, 默认值)`: 获取当前行往后第 $n$ 行的 `列名` 的值。

**需求：** 在每个部门内部，我想知道自己和前一名销售额的差距。

```sql
SELECT
    employee,
    department,
    amount,
    LAG(amount, 1, 0) OVER (PARTITION BY department ORDER BY amount DESC) AS previous_amount,
    amount - LAG(amount, 1, 0) OVER (PARTITION BY department ORDER BY amount DESC) AS diff_with_previous
FROM sales;
```

**结果：**

| employee | department | amount | previous_amount | diff_with_previous |
| :--- | :--- | :--- | :--- | :--- |
| 李四 | 销售A部 | 10000 | 0 | 10000 |
| 张三 | 销售A部 | 8000 | 10000 | -2000 |
| 孙七 | 销售A部 | 8000 | 8000 | 0 |
| 赵六 | 销售B部 | 12000 | 0 | 12000 |
| 王五 | 销售B部 | 9000 | 12000 | -3000 |

**来源和细节：**
- `LAG(amount, 1, 0)`:
  - `amount`: 我要获取的是 `amount` 列的值。
  - `1`: 往前数 $1$ 行。
  - `0`: 如果往前没有第 $1$ 行（比如分区内的第一名），就用 $0$ 作为默认值。
- 看“销售A部”的李四，他是第一名，`LAG`找不到上一行，所以 `previous_amount` 是 $0$。
- 看“销售A部”的张三，他的上一行是李四，所以 `previous_amount` 是李四的销售额 $10000$。
- `LEAD` 的用法完全相反，是看“下一行”。

### 总结

到这里，你已经学完了窗口函数的所有核心构件。它们就像乐高积木，你可以用：
1.  **`PARTITION BY`** 来选定积木的颜色（分组）。
2.  **`ORDER BY`** 来把同颜色的积木排好队。
3.  **`ROWS BETWEEN`** 来决定从队列里一次抓几块积木。
4.  **`分析函数()`** 来决定对抓出来的积木做什么（求和、排名等）。

将这些组合起来，你就能解决非常复杂的SQL查询问题，比如“查询每个部门里，销售额处于前 $5\%$ 的员工”、“查询每个用户连续登录的天数”等等。

希望这份超详细的笔记能帮助你真正入门窗口函数！
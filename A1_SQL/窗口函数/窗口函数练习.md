
# SQL 题目讲解 —— 窗口函数（一）

## 核心概念总结表

> [!TIP]
> 在深入学习之前，你可以先通过这个表格快速了解窗口函数的核心组件和它们的用途。

| 核心概念 | 通俗概括 | 主要语法 / 函数 |
| :--- | :--- | :--- |
| **窗口函数 (Window Function)** | 就像给数据表开了一扇可以移动的“窗户”，让你在不改变原有数据行数的情况下，对窗户里的数据进行计算。 | `函数() OVER (窗口定义)` |
| **窗口 (Window)** | 定义计算的范围，也就是“窗户”的大小和位置。 | `OVER (...)` |
| **`PARTITION BY`** | 像切蛋糕一样，把整个数据表按指定列（如班级）切成几大块，每块独立计算。 | `PARTITION BY 列名` |
| **`ORDER BY`** | 在切好的每一块“蛋糕”内部，把数据（如按分数）排个队，确定计算的顺序。 | `ORDER BY 列名` |
| **`ROWS` / `RANGE`** | 在排好队的队伍里，为每一行定义一个更小的、可以“滑动”的计算范围（例如“当前行和它前面的两行”）。 | `ROWS BETWEEN 上边界 AND 下边界` |
| **排序类函数** | 专门用来在窗口内给每一行数据打上排名或序号。 | `ROW_NUMBER()`, `RANK()`, `DENSE_RANK()` |
| **聚合类函数** | 我们熟悉的 `SUM`, `AVG` 等，但现在它们能在“窗口”里按行计算，而不是把所有行压缩成一行。 | `SUM()`, `AVG()`, `COUNT()`, `MAX()`, `MIN()` |
| **跨行类函数** | 像是能让你“回头看” (`LAG`) 和“向前看” (`LEAD`) 的函数，轻松获取上一行或下一行的数据。 | `LAG()`, `LEAD()` |

---

# 什么是窗口函数？

> **一句话概括**：窗口函数就像是给你的数据表开了一扇可以移动的“窗户”，让你在不改变原有数据行数的情况下，对窗户里的数据进行计算。

### 细节讲解
在我们深入之前，先理解两个词：

1.  **窗口 (Window)**：它不是一个真实存在的东西，而是一个我们定义的**范围**。想象一下，你有一张全班同学的成绩单，你想计算“每个班级内部的平均分”。这里的“每个班级”就是一个“窗口”或范围。
2.  **窗口函数 (Window Function)**：就是在这个你定义好的“窗口”范围内，去执行一个计算函数（比如求和 `SUM()`、求平均 `AVG()`）。

它的核心语法结构是：
$$
函数名(列名) OVER (窗口的定义)
$$
- `OVER` 是一个关键字，意思是“在...之上”，它宣告了窗口函数的开始。
- `OVER()` 括号里的部分，就是用来定义“窗口”的范围和规则的。
- `OVER()` 前面的部分，就是我们要执行的具体函数。

> [!WARNING]
> **重要提示**：视频中提到，窗口函数是 **MySQL 8.0** 及以上版本才支持的功能。如果你的MySQL版本低于 $8.0$，这些查询会报错。

### 演示用的数据表

为了方便理解，我们先创建一个简单的数据表，就像视频里那样：

| cid (班级ID) | s_name (学生姓名) | score (分数) |
| :--- | :--- | :--- |
| `001` | 王五 | $67$ |
| `001` | 张三 | $78$ |
| `001` | 李四 | $82$ |
| `002` | 小明 | $89$ |
| `002` | 小红 | $89$ |
| `002` | 小王 | $59$ |

---

# 窗口的确定：`OVER()`子句

> **一句话概括**：`OVER()` 子句通过三个小工具（`PARTITION BY`, `ORDER BY`, `ROWS`）共同定义了计算时那扇“窗户”的大小、位置和内部顺序。

`OVER()` 括号内部，通常由三个部分组成，来精确地定义窗口：
1.  **分组子句 (`PARTITION BY`)**：切分数据。
2.  **排序子句 (`ORDER BY`)**：在分组内排序。
3.  **窗口子句 (`ROWS`)**：定义更精细的行范围。

## `## 分组子句：PARTITION BY`

> **一句话概括**：`PARTITION BY` 就像切蛋糕，它把整个数据表按照你指定的列（比如班级 `cid`）切成几块，每一块都是一个独立的计算区域（窗口）。

它的作用是把数据**分区 (Partition)**。在每个分区内，窗口函数会独立进行计算，互不干扰。

### 例子：计算每个班级的总分

我们想在每一行都显示出该学生所在班级的总分。

$$
SELECT 
    *,
    SUM(score) OVER (PARTITION BY cid) AS '班级总分'
FROM 
    scores;
$$

**结果分析**:

| cid   | s_name | score | 班级总分  |
| :---- | :----- | :---- | :---- |
| `001` | 王五     | $67$  | $227$ |
| `001` | 张三     | $78$  | $227$ |
| `001` | 李四     | $82$  | $227$ |
| `002` | 小明     | $89$  | $237$ |
| `002` | 小红     | $89$  | $237$ |
| `002` | 小王     | $59$  | $237$ |

- **来源解释**:
    - 对于班级 `001` 的所有行，`班级总分` 都是 $227$。这个 $227$ 是怎么来的？它是 `001` 这个分区（窗口）里所有分数的和：$67 + 78 + 82 = 227$。
    - 对于班级 `002` 的所有行，`班级总分` 都是 $237$。这个 $237$ 是 `002` 这个分区里所有分数的和：$89 + 89 + 59 = 237$。

### `PARTITION BY` vs `GROUP BY`

> [!COMPARE]
> **重要区别**：`PARTITION BY` 和 `GROUP BY` 都能分组，但效果完全不同！

- **`GROUP BY` (分组聚合)**:
    - **作用**: 它会把多行数据**压缩**成一行。
    - **结果**: 最终的行数会**减少**。
    - **限制**: `SELECT` 子句中只能出现分组列和聚合函数，不能出现其他原始列（如 `s_name`）。
    - **示例**:
    $$
    SELECT cid, SUM(score) FROM scores GROUP BY cid;
    $$
    **结果**:

| cid   | SUM(score) |
| :---- | :--------- |
| `001` | $227$      |
| `002` | $237$      |
    (看，行数从 $6$ 行变成了 $2$ 行，学生姓名信息也没了)

- **`PARTITION BY` (窗口函数的分区)**:
    - **作用**: 它**不压缩**行数，而是在每一行上都附加一个计算结果。
    - **结果**: 最终的行数**不变**。
    - **限制**: 可以在 `SELECT` 子句中保留所有原始列（如 `*`）。
    - **总结**: `GROUP BY` 是为了**汇总报告**，`PARTITION BY` 是为了在**保留原始数据细节**的基础上，**增加分析列**。

## `## 排序子句：ORDER BY`

> **一句话概括**：在 `PARTITION BY` 切好的每一块“蛋糕”内部，`ORDER BY` 负责把数据（比如按分数）排个队。

这个 `ORDER BY` 只在窗口**内部**生效，它决定了窗口函数在计算时，看待这些行的顺序。这对于计算**累计值**或**排名**至关重要。

### 例子：计算从最低分到当前行的累计总分

$$
SELECT 
    *,
    SUM(score) OVER (PARTITION BY cid ORDER BY score) AS '累计分数'
FROM 
    scores;
$$

**结果分析**:

| cid | s_name | score | 累计分数 |
| :--- | :--- | :--- | :--- |
| `001` | 王五 | $67$ | $67$ |
| `001` | 张三 | $78$ | $145$ |
| `001` | 李四 | $82$ | $227$ |
| `002` | 小王 | $59$ | $59$ |
| `002` | 小明 | $89$ | $237$ |
| `002` | 小红 | $89$ | $237$ |

- **来源解释**:
    - 在 `001` 班（分区1），数据按分数 `score` 从低到高排序。
        - **王五** (`67`分): 窗口内只有他自己，累计分是 $67$。
        - **张三** (`78`分): 窗口扩展到他自己和之前所有行，累计分是 $67 + 78 = 145$。
        - **李四** (`82`分): 窗口扩展到他自己和之前所有行，累计分是 $145 + 82 = 227$。
    - 在 `002` 班（分区2），计算重新开始。
        - **小王** (`59`分): 累计分是 $59$。
        - **小明** 和 **小红** (`89`分): 因为他们分数相同，`ORDER BY` 会将他们视为同一批。窗口扩展到包含他们俩和之前的小王，所以累计分是 $59 + 89 + 89 = 237$。

## `## 窗口子句：ROWS` (滑动窗口)

> **一句话概括**：`ROWS` 子句在 `ORDER BY` 排好队的队伍里，为每一行定义一个更小的、可以“滑动”的计算范围。

`PARTITION BY` 和 `ORDER BY` 定义了一个大的、静态的窗口。而 `ROWS` 可以在这个大窗口内，为**每一行**数据定义一个动态的、更小的**滑动窗口**。这给了我们最精细的控制。

它的语法是 `ROWS BETWEEN 上边界 AND 下边界`。

**边界关键词**:
- `UNBOUNDED PRECEDING`: 从分区的最顶端开始。
- `n PRECEDING`: 从当前行往上数 `n` 行。
- `CURRENT ROW`: 当前行。
- `n FOLLOWING`: 从当前行往下数 `n` 行。
- `UNBOUNDED FOLLOWING`: 到分区的最末尾结束。

### 例子：再次理解“累计分数”

我们刚才那个“累计分数”的例子，其实是 `ROWS` 子句默认行为的结果。它的完整写法是：
$$
SELECT 
    *,
    SUM(score) OVER (
        PARTITION BY cid 
        ORDER BY score
        ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW
    ) AS '累计分数'
FROM 
    scores;
$$

**分步图解 (以001班为例)**:

1.  **静态窗口 (由 `PARTITION BY` 决定)**
    ```
    ┌──────────────────┐
    │ 王五 67          │  <-- 静态窗口上边界
    │ 张三 78          │
    │ 李四 82          │  <-- 静态窗口下边界
    └──────────────────┘
    ```

2.  **为每一行确定滑动窗口 (由 `ROWS` 决定)**
    - **计算王五这一行时**:
        - 上边界 `UNBOUNDED PRECEDING`: 追溯到分区顶部，就是王五自己。
        - 下边界 `CURRENT ROW`: 就是王五自己。
        - **滑动窗口**: `[王五]`，`SUM` 结果: $67$。

    - **计算张三这一行时**:
        - 上边界 `UNBOUNDED PRECEDING`: 追溯到分区顶部，是王五。
        - 下边界 `CURRENT ROW`: 就是张三自己。
        - **滑动窗口**: `[王五, 张三]`，`SUM` 结果: $67 + 78 = 145$。

    - **计算李四这一行时**:
        - 上边界 `UNBOUNDED PRECEDING`: 追溯到分区顶部，是王五。
        - 下边界 `CURRENT ROW`: 就是李四自己。
        - **滑动窗口**: `[王五, 张三, 李四]`，`SUM` 结果: $67 + 78 + 82 = 227$。

> [!INFO]
> **两个重要的默认规则**
> 1.  如果只写了 `ORDER BY`，没写 `ROWS`，那么 `ROWS` 默认就是 `ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW`。（这就是我们刚才的累计求和例子）
> 2.  如果连 `ORDER BY` 都没写（只写了 `PARTITION BY`），那么 `ROWS` 默认是 `ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING`，也就是整个分区。（这就是我们第一个计算“班级总分”的例子）

---

# 窗口函数本身：`OVER()`前面的部分

> **一句话概括**：定义好“窗口”之后，我们就要选择一个合适的函数，来对这个窗口内的数据进行计算。

主要有三大类函数。

## `## 1. 排序类函数`

> **一句话概括**：这类函数专门用来在窗口内给每一行数据打上排名或序号。

它们通常和 `ORDER BY` 配合使用。

| 函数 | 作用 | 例子 (假设分数是 100, 90, 90, 80) |
| :--- | :--- | :--- |
| `ROW_NUMBER()` | 连续排名，不考虑并列，像流水号。 | `1`, `2`, `3`, `4` |
| `RANK()` | 并列排名，但会跳过后续名次。 | `1`, `2`, `2`, `4` (第3名被跳过) |
| `DENSE_RANK()` | 并列排名，且是连续的，不会跳过名次。 | `1`, `2`, `2`, `3` (稠密排名) |

### 例子：给`002`班的学生按成绩排名

$$
SELECT
    s_name,
    score,
    ROW_NUMBER() OVER (ORDER BY score DESC) AS 'row_number_rank',
    RANK() OVER (ORDER BY score DESC) AS 'rank_rank',
    DENSE_RANK() OVER (ORDER BY score DESC) AS 'dense_rank_rank'
FROM scores
WHERE cid = '002';
$$

**结果分析**:
(002班的分数是: 小明 89, 小红 89, 小王 59)

| s_name | score | row_number_rank | rank_rank | dense_rank_rank |
| :--- | :--- | :--- | :--- | :--- |
| 小明 | $89$ | $1$ | $1$ | $1$ |
| 小红 | $89$ | $2$ | $1$ | $1$ |
| 小王 | $59$ | $3$ | $3$ | $2$ |

- **来源解释**:
    - `ROW_NUMBER()`: 不管分数是否相同，直接按顺序给出 $1, 2, 3$。
    - `RANK()`: 小明和小红都是 $89$ 分，并列第 $1$。因为有 $2$ 个人并列，所以下一个名次直接跳到第 $3$。
    - `DENSE_RANK()`: 小明和小红并列第 $1$。下一个名次紧跟着是第 $2$，不会跳过。

## `## 2. 聚合类函数`

> **一句话概括**：就是我们熟悉的 `SUM`, `AVG`, `COUNT` 等老朋友，但现在它们能在“窗口”里按行计算，而不是把所有行压缩成一行。

- `SUM()`: 求和
- `AVG()`: 求平均
- `COUNT()`: 计数
- `MAX()`: 求最大值
- `MIN()`: 求最小值

我们前面的“班级总分”和“累计分数”的例子，用的就是 `SUM()` 这个聚合类函数。

## `## 3. 跨行类函数`

> **一句话概括**：`LAG` 和 `LEAD` 就像是能让你“回头看”和“向前看”的函数，轻松获取上一行或下一行的数据。

- **`LAG(列名, 偏移量, 默认值)`**: 获取**之前**第N行的数据。
    - `列名`: 你想获取哪个列的数据。
    - `偏移量`: 往前看几行，默认是 $1$。
    - `默认值`: 如果往前看没有那一行（比如第一行），就显示这个默认值。
- **`LEAD(列名, 偏移量, 默认值)`**: 获取**之后**第N行的数据。参数同上。

### 例子：在`001`班，找出比自己成绩低一名的分数

$$
SELECT
    s_name,
    score,
    LAG(score, 1, 0) OVER (PARTITION BY cid ORDER BY score) AS '前一名分数'
FROM scores
WHERE cid = '001';
$$

**结果分析**:
(001班按分数从低到高是: 王五 67, 张三 78, 李四 82)

| s_name | score | 前一名分数 |
| :--- | :--- | :--- |
| 王五 | $67$ | $0$ |
| 张三 | $78$ | $67$ |
| 李四 | $82$ | $78$ |

- **来源解释**:
    - **王五**: 他是第一名（分数最低），前面没人，所以返回我们设置的默认值 $0$。
    - **张三**: 往前看 $1$ 行，是王五，所以返回王五的分数 $67$。
    - **李四**: 往前看 $1$ 行，是张三，所以返回张三的分数 $78$。

---
# 实战题目讲解

现在，我们用学到的知识来解决视频中的实际问题。

## 题目一：求每个学生成绩最高的$3$条记录 (分组Top N问题)

> [!NOTE]
> 这是一个非常典型的窗口函数应用场景，可以总结为一个“公式”。

**问题分析**:
1.  **“每个学生”**: 意味着我们要按学生 (`s_name`) 进行**分组** -> `PARTITION BY s_name`
2.  **“成绩最高”**: 意味着我们要按成绩 (`score`) **倒序排序** -> `ORDER BY score DESC`
3.  **“前$3$条”**: 意味着我们需要一个排名，然后筛选出排名小于等于 $3$ 的记录。

**为什么不能用 `GROUP BY`?**
因为 `GROUP BY` 会把每个学生的所有成绩记录压缩成一行（比如求最高分），我们就丢失了其他课程的成绩信息，无法得到“三条记录”。

### 解题步骤

**第一步：先用窗口函数生成排名列**
$$
SELECT
    *,
    ROW_NUMBER() OVER (PARTITION BY s_name ORDER BY score DESC) as rn
FROM 
    student_courses; -- 假设表名叫 student_courses
$$
- `ROW_NUMBER()` 在这里最合适，因为它能确保严格取出 $3$ 条记录。如果用 `RANK()` 或 `DENSE_RANK()`，遇到并列分数时可能会取出超过 $3$ 条记录。

**第二步：基于上一步的结果，筛选出 `rn <= 3` 的记录**
因为不能在 `WHERE` 子句中直接使用窗口函数生成的别名 `rn`，我们需要把第一步的查询作为**子查询**或**临时表**。

$$
SELECT * FROM (
    SELECT
        *,
        ROW_NUMBER() OVER (PARTITION BY s_name ORDER BY score DESC) as rn
    FROM 
        student_courses
) AS temp_table
WHERE rn <= 3;
$$

> [!TIP]
> **分组Top-N问题公式**:
> `SELECT * FROM (SELECT *, ROW_NUMBER() OVER (PARTITION BY 分组列 ORDER BY 排序比较列 DESC) as rn FROM 表) AS t WHERE rn <= N;`

## 题目二：找出每门课程都高于“班级课程平均分”的学生

**问题分析**: 这是一个复杂问题，我们可以拆解成几步：
1.  **计算“班级课程平均分”**: 需要一个按**班级**和**课程**分组的平均分。
2.  **比较差值**: 用每个学生的实际分数减去他所在班级该课程的平均分。
3.  **判断“每门都高于”**: 如果一个学生所有课程的这个差值**都大于0**，那么他就符合条件。这等价于，他所有课程差值里的**最小值**也大于 $0$。

### 解题步骤（使用 `WITH` 语句，更清晰）

`WITH` 语句可以创建临时的、有名字的查询结果集，让复杂的SQL逻辑更易读。

**第一步：计算每个班级每门课的平均分，并附加到每一行**
$$sql
WITH T1 AS (
    SELECT
        *,
        AVG(score) OVER (PARTITION BY cid, course) as avg_score
    FROM
        student_courses
)
-- 这一步的结果 T1 是在原表基础上增加了一列 avg_score
```
- **为什么用窗口函数？** 因为我们想在保留每一条学生成绩记录的同时，知道它对应的平均分是多少，方便下一步计算差值。用`GROUP BY`会丢失学生个人成绩。

**第二步：在`T1`的基础上，计算分数差值**
```sql
, T2 AS (
    SELECT
        *,
        score - avg_score as delta
    FROM T1
)
-- 这一步的结果 T2 是在 T1 基础上又增加了一列差值 delta
```

**第三步：在`T2`的基础上，分组找出差值最小值大于0的学生**
```sql
SELECT DISTINCT s_name
FROM T2
GROUP BY s_name
HAVING MIN(delta) > 0;
```
- 这里用 `GROUP BY s_name` 是为了把一个学生的所有课程记录聚合在一起。
- `HAVING MIN(delta) > 0` 正是我们分析出的核心逻辑：只要差值的最小值都大于零，那么所有差值肯定都大于零。

**完整SQL**:
$$
```sql
WITH T1 AS (
    SELECT
        *,
        AVG(score) OVER (PARTITION BY cid, course) as avg_score
    FROM
        student_courses
),
T2 AS (
    SELECT
        *,
        score - avg_score as delta
    FROM T1
)
SELECT DISTINCT s_name
FROM T2
GROUP BY s_name
HAVING MIN(delta) > 0;
$$

```


## 题目三：统计每年入职总数，和截止本年累计入职总数

**问题分析**:
1.  **每年入职总数**: 这是一个简单的分组聚合问题。按年份分组，然后计数。用 `GROUP BY` 最合适。
2.  **累计入职总数**: 在上一步结果的基础上，计算一个**累计和**。这是一个典型的窗口函数应用。

### 解题步骤

**第一步：用 `GROUP BY` 计算每年的入职人数**
$$
SELECT 
    YEAR(hire_date) as hire_year,
    COUNT(emp_id) as yearly_count
FROM 
    employees
GROUP BY 
    YEAR(hire_date)
ORDER BY
    hire_year;
$$

**第二步：将第一步结果作为临时表，计算累计总数**
$$
WITH yearly_hires AS (
    SELECT 
        YEAR(hire_date) as hire_year,
        COUNT(emp_id) as yearly_count
    FROM 
        employees
    GROUP BY 
        YEAR(hire_date)
)
SELECT
    hire_year,
    yearly_count,
    SUM(yearly_count) OVER (ORDER BY hire_year ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW) as cumulative_count
FROM
    yearly_hires;
$$
- **窗口定义解释**:
    - `ORDER BY hire_year`: 我们需要按年份顺序进行累计，所以排序是必须的。
    - `ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW`: 这定义了滑动窗口为“从最开始的年份到当前年份”，这正是“累计”的含义。
    - **为什么没有 `PARTITION BY`?** 因为我们是想统计全局的累计总数，而不是按某个部门或其他类别分开累计，所以不需要分区。


# 技巧总结


> [!abstract]
> 通过今天的学习，我们掌握了几个强大的技巧：

1.  **分组Top-N问题的“公式”**: 使用 `ROW_NUMBER()` 配合子查询，可以轻松解决“每个...的前N个...”这类问题。
2.  **用窗口函数生成“辅助列”**: 当你需要一个基于部分数据计算出的中间值（如平均分、总和），但又不想改变原表的行数时，窗口函数是最佳选择。它避免了复杂的 `GROUP BY` + `JOIN`。
3.  **用 `WITH` 语句拆解复杂问题**: 对于多步骤的复杂查询，使用 `WITH` 语句创建临时表，可以让你的思路更清晰，代码更易于阅读和调试，就像在写程序时一步步调用函数一样。
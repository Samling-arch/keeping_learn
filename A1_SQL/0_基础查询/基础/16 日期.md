
### 0.1.1 本节课核心知识点总结

| 查询目标 | 核心知识点 | 示例SQL (简化) |
| :--- | :--- | :--- |
| 准备工作 | 创建带 `DATE` 类型字段的新表 | `CREATE TABLE emp (..., birthday DATE);` |
| 查询某日之后出生 | 使用比较运算符 `>` | `WHERE birthday > '1990-01-01'` |
| 查询某日之前出生 | 使用比较运算符 `<` | `WHERE birthday < '1990-01-01'` |
| 查询某时间段出生 | 逻辑运算符 `AND` 组合比较 | `WHERE birthday > '1990-01-01' AND birthday < '2000-01-01'` |
| 查询特定年份出生 | 内置函数 `YEAR()` | `WHERE YEAR(birthday) = 1990` |
| 查询特定月份出生 | 内置函数 `MONTH()` | `WHERE MONTH(birthday) = 12` |
| 复杂跨月日期查询 | `AND`, `OR`, `()` 组合 `MONTH()` 和 `DAY()` | `WHERE (MONTH(b)=12 AND DAY(b)>=22) OR (MONTH(b)=1 AND DAY(b)<=19)` |

---

### 0.1.2 # 准备工作：创建一张带“生日”的员工表

> **一句话概括：** 工欲善其事，必先利其器。要学习日期查询，我们得先有一张包含日期数据的表。

我们之前的`emp`表里没有日期类型的数据，就像你想学游泳却没泳池一样。所以，我们第一步就是“建一个带泳池的场地”——创建一个新的`emp`表，并特意增加一个`birthday`（生日）字段，它的数据类型是`DATE`。

1.  **删除旧表 (如果存在)**
    ```sql
    DROP TABLE IF EXISTS emp;
    ```
    > **小白解惑：** `DROP TABLE` 就是“扔掉这张桌子”，直接把整张表和里面的数据全部删除。`IF EXISTS` 是一个保险措施，意思是“如果它存在的话（就删除）”，这样即使没有`emp`表，执行这句代码也不会报错。

2.  **创建新表并插入数据**
    我们创建一个新的`emp`表，这次多了一个字段 `birthday DATE`。然后插入一些带生日的员工记录。

    ```sql
    -- 创建新的emp表，注意多了一个birthday字段，类型是DATE
    CREATE TABLE emp (
        id INT,
        workno VARCHAR(20),
        name VARCHAR(20),
        gender CHAR(1),
        age INT,
        idcard CHAR(18),
        workaddress VARCHAR(50),
        entrydate DATE,
        birthday DATE -- 这就是我们新增的生日字段！
    );
    
    -- 插入一些示例数据，注意每个员工记录最后都加了生日信息
    INSERT INTO emp VALUES 
    (1,'10001','柳岩','女',26,'123456789012345678','北京','2008-01-01','1996-01-15'),
    (2,'10002','张无忌','男',22,'123456789012345671','北京','2018-03-01','2000-11-23'),
    (3,'10003','韦小宝','男',20,'123456789012345672','上海','2020-05-01','2002-08-08'),
    (4,'10004','赵敏','女',18,'123456789012345673','香港','2021-09-01','2004-12-25'),
    (5,'10005','周芷若','女',28,'123456789012345674','北京','2010-01-01','1994-01-08'),
    (6,'10006','令狐冲','男',45,'123456789012345675','西安','2001-01-01','1977-03-12'),
    (7,'10007','任我行','男',55,'123456789012345676','杭州','1998-01-01','1967-04-20'),
    (8,'10008','东方不败','男',48,'123456789012345677','南京','1999-01-01','1974-07-07'),
    (9,'10009','林平之','男',31,'123456789012345679','福建','2015-01-01','1991-09-01'),
    (10,'10010','岳不群','男',51,'123456789012345618','西安','1995-01-01','1971-10-24'),
    (11,'10011','任盈盈','女',29,'123456789012345628','杭州','2013-01-01','1993-11-05'),
    (12,'10012','小龙女','女',33,'123456789012345638','终南山','2007-01-01','1989-12-31'),
    (13,'10013','杨过','男',35,'123456789012345648','终南山','2006-01-01','1987-10-29'),
    (14,'10014','黄蓉','女',42,'123456789012345658','桃花岛','2002-01-01','1980-05-18'),
    (15,'10015','郭靖','男',43,'123456789012345668','蒙古','2001-08-01','1979-02-12');
    ```
    > **老师小提示：** 在某些SQL工具里，直接复制包含双引号 `"` 的代码可能会报错。最稳妥的方式是使用单引号 `'` 来包裹字符串，就像上面的例子一样。

---

### 0.1.3 # 基础日期比较：像比大小一样比早晚

> **一句话概括：** 就像比较数字 `$10` 和 `$5` 的大小一样，我们可以用 `>` 和 `<` 直接比较日期的早晚。

#### 0.1.3.1 ## 案例1：查询1990年以后出生的所有员工

```sql
SELECT * FROM emp WHERE birthday > '1990-01-01';
```

**小白解惑（这个太神奇了，为什么可以这样写？）：**
你可能会好奇，`'1990-01-01'` 明明是一个用单引号包起来的字符串，为什么能和 `birthday` 这个日期类型进行“大于”比较呢？

*   **MySQL的“翻译官”：** 当MySQL的查询引擎执行到这里时，它非常聪明。它看到 `>` 左边是 `DATE` 类型的 `birthday`，右边是一个 `'年-月-日'` 格式的字符串。它会自动调用内部的“翻译官”，把这个字符串 `'1990-01-01'` 转换成一个真正的日期对象。
*   **时间戳的奥秘：** 在电脑内部，所有日期最终都可以被转换成一个独一无二的数字，我们通俗地称之为“时间戳”。越晚的日期，它的时间戳数字就越大。所以，比较两个日期的早晚，本质上就是在比较它们对应时间戳的大小。
*   **所以，`birthday > '1990-01-01'` 的真正含义是：** “把员工的生日转换成时间戳，再把`'1990-01-01'`也转换成时间戳，然后比较前者的数字是否大于后者。”

**举一反三：查询1990年以前出生的所有员工**
只需要把 `>` 换成 `<` 即可。

```sql
SELECT * FROM emp WHERE birthday < '1990-01-01';
```

---

### 0.1.4 # 日期范围查询：圈定一个时间段

> **一句话概括：** 通过设定一个开始时间和结束时间，把这个时间段内出生的员工都“捞”出来。

#### 0.1.4.1 ## 案例2：查询“90后”员工 (即1990年到2000年之间出生的)

```sql
SELECT *
FROM emp
WHERE
    birthday >= '1990-01-01' AND birthday < '2000-01-01';
```
**小白解惑（这里的AND是什么意思？）：**
*   `AND` 是逻辑“与”，意思是“并且”。整个 `WHERE` 条件可以读作：“筛选出那些生日 **大于等于**`'1990-01-01'` **并且** 生日 **小于** `'2000-01-01'` 的员工”。两个条件必须同时满足，才会被选中。

**另一种写法（更精确到天）：**
你也可以这样写，效果完全一样，有时候逻辑上更容易理解：查询生日在`1990年1月1日`（含）到`1999年12月31日`（含）之间的员工。

```sql
SELECT *
FROM emp
WHERE
    birthday >= '1990-01-01' AND birthday <= '1999-12-31';
```
> **细节对比：** `'2000-01-01'` 之前的一天就是 `'1999-12-31'`。所以 `birthday < '2000-01-01'` 和 `birthday <= '1999-12-31'` 对于 `DATE` 类型来说效果是等价的。选择哪种写法取决于个人习惯。

---

### 0.1.5 # 日期函数入门：精确提取年、月、日

> **一句话概括：** MySQL给我们提供了“手术刀”一样的工具（内置函数），可以从完整的“年月日”中，精确地把“年”或者“月”单独取出来进行判断。

#### 0.1.5.1 ## 案例3：查询所有在`1990`年**这一整年**出生的员工

如果用范围查询，你需要写 `birthday >= '1990-01-01' AND birthday <= '1990-12-31'`，有点麻烦。现在我们有了更强大的工具！

```sql
SELECT * FROM emp WHERE YEAR(birthday) = 1990;
```
**小白解惑（`YEAR(birthday)` 是什么魔法？）：**
*   `YEAR()` 是MySQL提供的一个**内置函数**。它的作用就像一个“年份提取器”。
*   **工作流程：**
    1.  当查询引擎扫描到第一条员工记录时，它会把这条记录的 `birthday` 值（例如 `'1996-01-15'`）“喂”给 `YEAR()` 函数。
    2.  `YEAR()` 函数“吃”掉这个日期后，会“吐”出其中的年份部分，也就是数字 `$1996$`。
    3.  然后，引擎会判断 `$1996` 是否等于 `$1990$`。结果是不等，所以这条记录被跳过。
    4.  引擎继续扫描，直到找到一个 `birthday`，`YEAR()` 函数提取出的年份正好等于 `$1990$`，这条记录才会被选中。
*   **注意：** 因为 `YEAR()` 函数返回的是一个纯数字（如 `$1990$`），所以我们用 `=` 直接和数字 `$1990$` 比较，不再需要写单引号了。

#### 0.1.5.2 ## 案例4：查询所有`12`月份出生的员工

同理，我们可以用 `MONTH()` 函数来提取月份。

```sql
SELECT * FROM emp WHERE MONTH(birthday) = 12;
```
**小白解惑：**
*   `MONTH()` 函数和 `YEAR()` 师出同门，它是一个“月份提取器”。`MONTH('1996-01-15')` 会返回数字 `$1$`。
*   所以 `MONTH(birthday) = 12` 的意思就是“把生日中的月份提取出来，看看是不是等于`$12$`”。

> **知识拓展：** 除了 `YEAR()` 和 `MONTH()`，还有一个常用的函数叫 `DAY()`，用来提取是几号。比如 `DAY('1996-01-15')` 会返回数字 `$15$`。这个我们马上就会用到！

---

### 0.1.6 # 终极挑战：复杂的星座查询

> **一句话概括：** 当查询逻辑跨越月份时，我们需要像拼乐高一样，把 `AND`（并且）、`OR`（或者）和 `()`（括号）组合起来，构建出精确的筛选条件。

#### 0.1.6.1 ## 案例5：查询所有摩羯座的员工

首先，我们要查一下摩羯座的日期范围：**12月22日 到 1月19日**。

**错误思路分析：**
很多同学第一反应是：`WHERE birthday >= '12-22' AND birthday <= '01-19'`。
这是**完全错误**的！为什么？
1.  **格式不对：** `'12-22'` 不是一个完整的 `YYYY-MM-DD` 日期，MySQL无法正确解析。
2.  **逻辑不通：** 这个范围横跨了两年。一个日期不可能同时大于12月又小于1月。

**正确逻辑分解：**
摩羯座的人，要么满足条件A，要么满足条件B：
*   **条件A：** 在12月份出生，并且日期大于等于22号。
    *   `MONTH(birthday) = 12` **AND** `DAY(birthday) >= 22`
*   **条件B：** 在1月份出生，并且日期小于等于19号。
    *   `MONTH(birthday) = 1` **AND** `DAY(birthday) <= 19`

最终的筛选逻辑是：**(满足条件A) 或者 (满足条件B)**。在SQL里，“或者”就是 `OR`。

```sql
SELECT *
FROM emp
WHERE
    -- 第一个括号内是条件A：12月22日及以后
    (MONTH(birthday) = 12 AND DAY(birthday) >= 22)
OR
    -- 第二个括号内是条件B：1月19日及以前
    (MONTH(birthday) = 1 AND DAY(birthday) <= 19);
```
**小白解惑（括号`()`的作用）：**
*   括号在这里至关重要！它用来**规定运算的优先级**。
*   就像数学里的 `(2 + 3) * 4` 一样，必须先算括号里的。
*   这里，`()` 确保了 `MONTH(...) AND DAY(...)` 这两个紧密相关的条件先被判断，形成一个完整的“条件A”或“条件B”。
*   然后再用 `OR` 连接这两个已经算好的结果。如果没有括号，`AND`的优先级会高于`OR`，查询逻辑就会完全混乱。

#### 0.1.6.2 ## 举一反三：查询所有天蝎座的员工

天蝎座的日期范围是：**10月24日 到 11月22日**。
这个逻辑和摩羯座完全一样，只是换了月份和日期。

**逻辑分解：**
*   **条件A：** 月份是`$10$` **并且** 日子大于等于`$24$`
*   **条件B：** 月份是`$11$` **并且** 日子小于等于`$22$`
*   **最终逻辑：** (条件A) **OR** (条件B)

```sql
SELECT *
FROM emp
WHERE
    (MONTH(birthday) = 10 AND DAY(birthday) >= 24)
OR
    (MONTH(birthday) = 11 AND DAY(birthday) <= 22);
```

好了同学，关于日期的各种查询我们就讲到这里了。从最简单的 `>` 比较，到使用 `YEAR`、`MONTH` 函数，再到最复杂的星座查询，你已经掌握了日常开发中`99%`的日期查询场景。多敲几遍，加深理解，你就是日期查询小能手了！
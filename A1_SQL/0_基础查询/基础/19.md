好的，同学！这节课我们来深入学习 SQL 中的 `GROUP BY` 和 `HAVING`。我会用 Obsidian 的 Markdown 格式，把每个知识点都掰开揉碎了讲给你听，保证你这个0基础小白也能彻底搞懂！

### 表格总结：`WHERE` vs `HAVING` 核心区别

| 特性 | `WHERE` 子句 | `HAVING` 子句 |
| :--- | :--- | :--- |
| **一句话概括** | 在数据分组**前**，对**每一条原始记录**进行筛选。 | 在数据分组**后**，对**分组后的结果**进行筛选。 |
| **执行顺序** | 在 `GROUP BY` 之前执行 (`FROM` -> `WHERE` -> `GROUP BY`) | 在 `GROUP BY` 之后执行 (`GROUP BY` -> `HAVING` -> `SELECT`) |
| **筛选对象** | 数据库表中的原始行（row） | 由 `GROUP BY` 生成的组（group） |
| **能否用聚合函数**| **不能**。因为此时还没分组，没有组的统计结果。 | **可以**。`HAVING` 的核心就是对聚合函数的结果进行筛选。 |
| **打个比方** | 比如全班同学站队，`WHERE` 就是先喊“身高不到1米6的同学请出列”，剩下的人再按男女分组。 | `HAVING` 是全班同学先按男女分好组，然后喊“男生组平均身高不到1米8的，整组淘汰”。 |

---

### # 课程开始：理解 `HAVING` 的作用

一句话概括：`HAVING` 就是分组查询的“过滤器”，专门用来筛选那些分组后的统计结果。

我们已经学过一个完整的 `SELECT` 语句的顺序是：

`SELECT ... FROM ... WHERE ... GROUP BY ... HAVING ... ORDER BY ... LIMIT ...`

- `$FROM$`: 从哪张表里拿数据。
- `$WHERE$`: **分组前**的筛选器，筛选**单条记录**。
- `$GROUP BY$`: 按什么规则把数据分成一堆一堆的。
- `$HAVING$`: **分组后**的筛选器，筛选**整个分组**。
- `$SELECT$`: 决定最终显示哪些列。
- `$ORDER BY$`: 按什么规则对最终结果排序。
- `$LIMIT$`: 只显示几条结果。

`$HAVING$` 和 `$GROUP BY$` 总是成对出现，形影不离。没有 `$GROUP BY$`，就几乎用不到 `$HAVING$`。

---

### # 案例一：查询男女员工各有多少人（`GROUP BY` 复习）

一句话概括：这是最基础的分组查询，按某个字段（性别）把数据分成几堆，然后分别对每堆数数。

**需求分析：**
我们要查询“男女员工”，这意味着要把所有员工分成“男”和“女”两个组。然后要统计“各有多少人”，这是一个计数操作。这完全符合“先分组，后统计”的思路。

**SQL 实现：**
```sql
$$
SELECT
    gender AS '性别',
    COUNT(*) AS '人数'
FROM
    emp
GROUP BY
    gender;
$$
```

**细节拆解：**
1.  `FROM emp`: 首先，数据库找到 `$emp$` 这张员工表，把所有数据准备好。
2.  `GROUP BY gender`: 接着，它会查看每一条记录的 `$gender$` 字段。所有 `$gender$` 是'男'的记录被放进一个组，所有是'女'的记录被放进另一个组。这时，数据就从一大堆变成了两个小堆。
3.  `SELECT gender, COUNT(*)`:
    -   `gender`: 这是分组的依据，所以可以直接显示出来，代表这一组是“男”还是“女”。
    -   `COUNT(*)`: 这是一个**聚合函数**，`*` 代表一行记录，`COUNT` 就是数数。它会分别对“男”组和“女”组进行操作，数出每个组里有多少条记录。
4.  `AS '性别'` 和 `AS '人数'`: 这是给查询结果的列起一个中文别名，让结果看起来更清晰。

**执行结果：**
```
+------+--------+
| 性别 | 人数   |
+------+--------+
| 男   |     18 |
| 女   |     14 |
+------+--------+
```

---

### # 案例一拓展：查询年龄大于25岁的男女员工各有多少人（`WHERE` 的作用）

一句话概括：先用 `$WHERE$` 把不符合条件的单条记录（年龄小于等于25的）扔掉，再用剩下的记录去分组统计。

**需求分析：**
这次，我们不是对所有员工进行分组了，而是有一个前提条件：“年龄大于25岁”。这个条件是针对**每一个员工个体**的，而不是针对分组后的结果。所以，它应该在分组前完成筛选。

**SQL 实现：**
```sql
$$
SELECT
    gender AS '性别',
    COUNT(*) AS '人数'
FROM
    emp
WHERE
    age > 25
GROUP BY
    gender;
$$
```

**细节拆解（执行顺序是关键！）：**
1.  `FROM emp`: 数据库找到 `$emp$` 表，假设有 `$32$` 条员工记录。
2.  `WHERE age > 25`: 这是第二步！数据库会一条一条地检查这 `$32$` 条记录，把 `$age$` 字段值不大于 `$25$` 的记录全部扔掉。假设扔掉之后，只剩下了 `$16$` 条记录。
3.  `GROUP BY gender`: **现在，数据库只用这剩下的 `$16$` 条记录来进行分组**。它会把这 `$16$` 人分成“男”组和“女”组。
4.  `SELECT ... COUNT(*)`: 最后，对这两个新形成的小组分别进行计数。

**对比思考：**
- 第一个例子是基于全部 `$32$` 名员工进行分组，所以男女总人数是 `$32$`。
- 这个例子是先筛选出 `$16$` 名符合条件的员工，再对这 `$16$` 人进行分组，所以男女总人数是 `$16$`。
> **记住**：`$WHERE$` 发生在 `$GROUP BY$` 之前，它决定了**哪些记录有资格参与分组**。

---

### # 案例二：查询教学部的员工最高工资（`HAVING` 初体验）

一句话概括：先用 `$GROUP BY$` 算出每个部门的统计结果（最高工资），然后用 `$HAVING$` 从这些结果里挑出我们想要的那个部门。

**需求分析：**
1.  我们想知道“最高工资”，但不是全公司的，而是分“部门”的。所以第一步是按部门分组，计算每个部门的最高工资。
2.  计算出所有部门的最高工资后，我们只关心“教学部”的，需要把其他部门的过滤掉。这个过滤操作是针对**分组后的结果**的。

**SQL 实现 (使用 `HAVING`)：**
```sql
$$
SELECT
    dep AS '部门',
    MAX(salary) AS '最高工资'
FROM
    emp
GROUP BY
    dep
HAVING
    dep = '教学部';
$$
```

**细节拆解：**
1.  `FROM emp`: 找到员工表。
2.  `GROUP BY dep`: 按部门（`$dep$`）字段分组，形成“教学部”、“运营部”、“销售部”等几个组。
3.  `SELECT dep, MAX(salary)`: 对每个组，计算最高工资（`MAX(salary)`）。到这一步，内存中的结果可能是这样的：
    ```
    教学部, 12000
    运营部, 12000
    销售部, 12000
    ```
4.  `HAVING dep = '教学部'`: **这是关键！** `HAVING` 子句开始工作，它检查上面内存中的三条分组结果，把 `$dep$` 字段不是'教学部'的组给过滤掉。
5.  最终，只有“教学部”那一条结果被留下来并显示。

**执行结果：**
```
+--------+----------+
| 部门   | 最高工资 |
+--------+----------+
| 教学部 |    12000 |
+--------+----------+
```

**另一种思路（使用`WHERE`）：**
我们也可以先筛选出所有教学部的员工，再对这些人求最高工资。

```sql
$$
SELECT
    dep AS '部门',
    MAX(salary) AS '最高工资'
FROM
    emp
WHERE
    dep = '教学部';
$$
```
**细节拆解：**
1. `FROM emp`: 找到员工表。
2. `WHERE dep = '教学部'`: 先把所有不是教学部的员工记录都扔掉。
3. `MAX(salary)`: 在剩下的（全都是教学部的）员工记录里，找一个最大的工资。这里甚至可以不用 `GROUP BY`，因为经过 `WHERE` 筛选后，所有记录都属于同一个“教学部”大组了。

> 这两种方法结果一样，但思路不同。`HAVING` 是“先分组，后过滤组”，`WHERE` 是“先过滤记录，后对剩下的记录操作”。对于这个特定问题，用 `WHERE` 更高效。但下一个例子，就必须用 `HAVING` 了。

---

### # 案例三：查询平均薪水超过8500的部门（`HAVING` 的核心用法）

一句话概括：这是一个典型的 `$HAVING$` 用法，因为“平均薪水”这个条件，必须在数据分组并计算出平均值之后才能用来判断和过滤。

**需求分析：**
- 条件是“平均薪水超过$8500$”。
- “平均薪水”这个值，对于单条员工记录来说是没有意义的，它必须是**一个部门的平均薪水**。
- 所以，我们必须先按部门分组，算出每个部门的平均薪水，然后才能用“> $8500$”这个条件去筛选。

**SQL 实现：**
```sql
$$
SELECT
    dep AS '部门',
    AVG(salary) AS 'avg_salary'
FROM
    emp
GROUP BY
    dep
HAVING
    AVG(salary) > 8500;
$$
```
或者使用别名（更推荐，更简洁）：
```sql
$$
SELECT
    dep AS '部门',
    AVG(salary) AS 'avg_salary' -- 给平均薪资起个别名
FROM
    emp
GROUP BY
    dep
HAVING
    avg_salary > 8500; -- 直接用别名进行判断
$$
```

**细节拆解：**
1.  `FROM emp` -> `GROUP BY dep`: 和之前一样，按部门分组。
2.  `SELECT dep, AVG(salary) AS 'avg_salary'`: 对每个组，计算平均薪水 (`AVG(salary)`)，并给这个计算结果起个别名 `avg_salary`。内存中的结果可能是：
    ```
    教学部, 8833.33
    运营部, 8750.00
    销售部, 8300.00
    ```
3.  `HAVING avg_salary > 8500`: `HAVING` 子句检查这三条分组结果，它会看 `avg_salary` 这一列的值。`8300.00` 不大于 `$8500$`，所以“销售部”这一组被过滤掉。
4.  最终显示剩下的两组。

**为什么这里不能用 `WHERE`？**
如果你尝试写 `WHERE AVG(salary) > 8500`，数据库会直接报错！因为 `$WHERE$` 在 `$GROUP BY$` 之前执行，它操作的是原始的、一行一行的记录。在那个阶段，数据库根本不知道“部门平均薪水”是多少，所以无法进行判断。

---

### # 案例四：查询每个部门所有员工的姓名（`GROUP_CONCAT` 函数）

一句话概括：当你想把一个分组里的多行文本信息合并成一个单元格显示时，使用 `$GROUP_CONCAT$` 函数。

**错误尝试：**
如果我们直接 `SELECT name` 会怎样？
`SELECT dep, name FROM emp GROUP BY dep;`
这会报错！因为分组后，比如“教学部”组里有很多个员工，每个员工都有自己的 `$name$`。数据库懵了：你到底要我显示哪个名字？张三？李四？还是王五？因为不明确，所以会报错。

**正确实现：**
我们需要一个能把组内所有名字都显示出来的办法。`$GROUP_CONCAT$` 就是为此而生的。

```sql
$$
SELECT
    dep AS '部门',
    GROUP_CONCAT(name) AS '所有员工姓名'
FROM
    emp
GROUP BY
    dep;
$$
```

**细节拆解：**
- `GROUP_CONCAT(name)`: 这可以看作一个“字符串聚合函数”。它会找到当前分组内的所有记录，把它们的 `$name$` 字段值取出来，用逗号（默认）连接成一个长字符串。
- 这样，对于每一个分组（部门），我们都得到了一个明确的、唯一的显示结果（一长串名字）。

**执行结果：**
```
+--------+------------------------------------------+
| 部门   | 所有员工姓名                             |
+--------+------------------------------------------+
| 教学部 | 张三,李四,王五,赵六...                    |
| 运营部 | 周七,吴八,郑九...                        |
+--------+------------------------------------------+
```

---

### # 案例五、六、七：其他分组与聚合练习

#### 1. 查询公司员工总数/平均工资

一句话概括：当你想对所有数据进行统计（而不是分小组统计）时，可以直接使用聚合函数，省略 `$GROUP BY$` 子句。

**SQL 实现：**
```sql
$$
-- 查询总人数
SELECT COUNT(*) AS '公司总人数' FROM emp;

-- 查询平均工资
SELECT AVG(salary) AS '公司平均工资' FROM emp;
$$
```

**细节拆解：**
- 当没有 `$GROUP BY$` 子句时，聚合函数（如 `$COUNT$`, `$AVG$`）会把整张表的所有记录当作一个**大的、唯一的组**来处理。
- `COUNT(*)` 就是数这个大组里有多少条记录。
- `AVG(salary)` 就是计算这个大组里所有记录的 `$salary$` 字段的平均值。

#### 2. 查询每年出生的员工数

一句话概括：我们可以使用函数（如 `$YEAR()`）从原始数据列（如生日）中提取出一部分信息（年份），然后根据这个提取出的信息来进行分组。

**需求分析：**
我们要按“年”来分组，而不是按完整的“年月日”(`$birthday$`)。所以，我们需要从 `$birthday$` 字段中只把年份提取出来。

**SQL 实现：**
```sql
$$
SELECT
    YEAR(birthday) AS '出生年份',
    COUNT(*) AS '出生人数'
FROM
    emp
GROUP BY
    YEAR(birthday) -- 按年份进行分组
ORDER BY
    `出生年份` DESC; -- 按出生年份降序排一下
$$
```

**细节拆解：**
- `YEAR(birthday)`: 这是一个日期函数，可以从一个日期时间类型的值（如 `'1999-05-10'`）中提取出年份（`$1999$`）。
- `GROUP BY YEAR(birthday)`: 数据库会先对每一条记录计算出其出生年份，然后所有年份相同的记录被分到同一个组。例如，所有 `$1999$` 年出生的员工会成为一个组。
- `ORDER BY \`出生年份\` DESC`: 使用反引号包裹中文别名进行排序，`DESC` 表示降序，这样我们能先看到最近年份出生的人数。

---

### # 总结

好了同学，今天我们通过大量的练习，把 `$HAVING$` 和 `$GROUP BY$` 的用法彻底搞明白了。

- **核心中的核心**：记住那张对比表格，**`WHERE` 在分组前过滤记录，`HAVING` 在分组后过滤组**。
- **能力拓展**：我们还学会了如何对一个函数计算出的结果进行分组（如 `YEAR(birthday)`），以及如何使用 `GROUP_CONCAT` 合并组内信息。
- **全局视角**：我们还知道了聚合函数不一定非要跟 `GROUP BY` 一起用，没有 `GROUP BY` 时，它会对整张表进行统计。

把这些案例在自己的数据库里多敲几遍，你对分组查询的理解就会越来越深刻！
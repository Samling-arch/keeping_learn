好的同学，没问题！我们来把更新和删除记录这一课，用非常适合小白的、细节满满的Obsidian Markdown格式来重新梳理一遍。

# 1 SQL 记录操作：更新与删除

## 1.1 课程核心知识点总结

> [!TIP] Obsidian 小贴士
> 下面这个表格是用Markdown的表格语法制作的。每一列用 `|` 分隔，表头和内容之间用 `|---|` 分隔。这在Obsidian里会渲染成一个非常漂亮的表格，方便你总结和回顾。

| 操作 (Action) | 关键字 (Keyword) | 核心功能 (Core Function) |
| :--- | :--- | :--- |
| **添加记录** | `INSERT` | 向表中放入一行全新的数据。 |
| **查询记录** | `SELECT` | 从表中按照各种条件“捞”出我们想要看的数据。 |
| **更新记录** | `UPDATE` | 找到表中已经存在的某些行，修改其中某些格子的内容。 |
| **删除记录** | `DELETE` | 找到表中已经存在的某些行，然后把这些行整个从表中移除。 |

---

## 1.2 第三节：更新记录 (`UPDATE`)

> **一句话概括**：`UPDATE` 命令就是你的“修改液”，可以帮你找到表里的特定记录，然后涂掉旧内容，写上新内容。

### 1.2.1 核心语法解析

通俗来说，更新记录的逻辑就是：“嘿，数据库，你帮我 **更新** 一下 `这个表`，**把** `这个字段` **设置成** `这个新值`，但前提是，你得先找到 **符合** `这个条件` 的那些记录才行。”

这个逻辑转换成SQL语法就是：

$$
UPDATE 表名 SET 字段1 = 新值1, 字段2 = 新值2, ... WHERE 条件;
$$

我们来把这个公式拆解成每一个小零件，看看它们都是干嘛的：

*   `UPDATE 表名`: 这是命令的开头，告诉数据库：“准备好，我要开始修改操作了！”，`表名` 就是你要修改哪张表，比如我们的 `emp` 表。
*   `SET 字段 = 值`: `SET` 的意思是“设置”。紧跟在它后面的 `字段 = 值` 就是具体的修改内容。你可以同时修改多个字段，用逗号 `,` 隔开，比如 `SET job = '经理', salary = 8000`。
    *   **来源**: 这个 `SET` 语法和我们之前学的 `INSERT INTO 表名 SET 字段=值;` 非常像，对吧？它们都用 `SET` 来指定“哪个字段等于哪个值”，非常直观。你可以把 `INSERT` 的 `SET` 理解为在新画的一张空白卡片上填写信息，而 `UPDATE` 的 `SET` 是在已有的旧卡片上修改信息。
*   `WHERE 条件`: 这是 **`UPDATE` 命令的灵魂，也是最需要小心的地方**。它就像一个筛选器，告诉数据库：“不要修改所有记录，只修改那些满足我 `WHERE` 后面条件的记录！”
    *   **来源**: 这个 `WHERE` 子句和我们第二节课学的 `SELECT ... WHERE ...` 里的 `WHERE` 是**一模一样**的！你之前怎么用 `WHERE` 筛选查询数据，现在就怎么用它来筛选要更新的数据。这就是为什么老师说学完查询，更新就水到渠成了。

> [!WARNING] **严重警告：`UPDATE` 命令千万不能忘了 `WHERE`**
> 如果你在 `UPDATE` 语句中不写 `WHERE` 条件，数据库会认为你想修改 **表中的每一条记录**！
> 比如，`UPDATE emp SET salary = 1000000;` 这条命令，如果没有 `WHERE`，将会把公司所有员工的工资都改成一百万！这在真实工作中可能是个巨大的灾难。

### 1.2.2 实战案例

我们来一步步实践，把老师讲的案例都走一遍。

#### 1.2.2.1 案例一：将'苑'老师的薪资更新为 `$99999`

*   **目标**: 精准定位到 `name` 字段为 `'yuan'` 的那条记录，并只修改它的 `salary` 字段。
*   **思路**:
    1.  用 `UPDATE emp` 告诉数据库我们要修改 `emp` 表。
    2.  用 `SET salary = 99999` 告诉数据库我们想把薪水改成 `$99999`。
    3.  用 `WHERE name = 'yuan'` 作为筛选条件，确保只修改“苑老师”这一条记录。
*   **SQL代码**:

    > [!NOTE] Obsidian 小贴士
    > 下面的SQL代码块使用了三个反引号 ```sql ... ``` 包裹。在Obsidian里，这样可以实现代码高亮，让代码更好看、更易读。

    ```sql
    UPDATE emp
    SET salary = 99999
    WHERE name = 'yuan';
    ```

*   **细节剖析**:
    *   老师在课堂上第一次尝试设置为 `$1000000` 时报错了。为什么呢？因为在创建 `emp` 表的时候，我们给 `salary` 字段设置了类型和范围，比如 `DECIMAL(7, 2)`。这个类型表示薪资总共最多 `$7` 位数，其中小数占 `$2` 位。所以整数部分最多只能是 `$5` 位数，即最大为 `$99999.99`。`$1000000` 有 `$7` 位整数，超出了定义的范围，所以数据库拒绝了这次更新。这个细节告诉我们，数据库会严格遵守你创建表时定下的规矩！
    *   执行成功后，你可以用 `SELECT * FROM emp WHERE name = 'yuan';` 来检查一下，苑老师的工资是不是真的变了。

#### 1.2.2.2 案例二：将所有“运营部”的部门名称改为“用户增长部”

*   **目标**: 找到 `dep` 字段为 `'运营部'` 的 **所有** 记录，并将它们的 `dep` 字段统一修改为 `'用户增长部'`。
*   **思路**:
    1.  `UPDATE emp`：还是修改 `emp` 表。
    2.  `SET dep = '用户增长部'`：把 `dep` 字段的值设为新名称。
    3.  `WHERE dep = '运营部'`：筛选条件是，原来的部门必须是 `'运营部'`。
*   **SQL代码**:
    ```sql
    UPDATE emp
    SET dep = '用户增长部'
    WHERE dep = '运营部';
    ```
*   **细节剖析**:
    *   这个案例的巧妙之处在于，我们用来筛选的字段 (`dep`) 和我们实际要修改的字段 (`dep`) 是同一个。这很常见，比如批量改错别字、部门更名等。
    *   **重要区分**: 我们这里修改的是记录的 **值** (Value)，比如从 `'运营部'` 这个字符串变成了 `'用户增长部'`。这和修改表的 **结构** (Structure) 是完全不同的。如果你想把 `dep` 这个字段名改成 `department_name`，那就需要用 `ALTER TABLE emp CHANGE dep department_name ...` 这样的命令了，那是对表结构的操作。

#### 1.2.2.3 案例三：为年龄大于 `$35$` 岁的员工加薪 `$15\%`

*   **目标**: 对满足年龄条件的员工，在他们 **现有工资** 的基础上进行计算，并更新工资。
*   **思路**:
    1.  `UPDATE emp`：修改 `emp` 表。
    2.  `SET salary = salary * 1.15`：这是本例的精华！我们不是把 `salary` 设置成一个固定的值，而是把它设置成 “它原来的值 `* 1.15`”。数据库在处理每一条符合条件的记录时，都会先读取它当前的 `salary` 值，计算出新值，然后再写回去。
    3.  `WHERE age > 35`：筛选出所有年龄大于 `$35$` 岁的员工。
*   **SQL代码**:
    ```sql
    UPDATE emp
    SET salary = salary * 1.15
    WHERE age > 35;
    ```
*   **细节剖析**:
    *   `salary = salary * 1.15` 这种写法非常强大和灵活。它展示了 `SET` 子句的右边不仅可以是一个固定的值，还可以是一个包含原字段的表达式。加薪、减薪、积分翻倍等业务逻辑都可以用这种方式轻松实现。
    *   比如老师举的例子：Sarah原来工资是 `$10000`，年龄 `$38` 岁（大于`$35`），那么更新后她的工资就是 `$10000 * 1.15 = 11500`。数据库会对每一条符合条件的记录都执行一次这样的计算。

#### 1.2.2.4 案例四：给薪资最高的 `$5$` 名员工降薪 `$30\%`

*   **目标**: 先找出工资排名在前五的员工，然后给他们降薪 `$30\%$`。
*   **思路**: 这个案例融合了查询中的排序和限制功能，非常综合。
    1.  `UPDATE emp`：修改 `emp` 表。
    2.  `SET salary = salary * 0.7`：降薪 `$30\%`，就等于原来的工资乘以 `$0.7` (1 - 30%)。
    3.  `ORDER BY salary DESC LIMIT 5`：这部分是关键。它不是 `WHERE` 子句，而是直接跟在 `UPDATE` 语句后面的排序和限制子句（这是MySQL等数据库支持的强大语法）。它的意思是：在更新之前，请先将 `emp` 表的所有记录按 `salary` 从高到低 (`DESC`) 排序，然后只对排在最前面的 `$5$` 条记录执行 `SET` 操作。
*   **SQL代码**:
    ```sql
    UPDATE emp
    SET salary = salary * 0.7
    ORDER BY salary DESC
    LIMIT 5;
    ```
*   **细节剖析**:
    *   **验证好习惯**: 像老师做的那样，在执行这种复杂的 `UPDATE` 前，先用 `SELECT` 语句来“侦察”一下，看看你将要修改的到底是哪些数据。
        1.  **侦察**: `SELECT * FROM emp ORDER BY salary DESC LIMIT 5;` 先运行这个，看看目前工资最高的五个人是谁，记下他们的工资。
        2.  **执行**: 运行上面的 `UPDATE` 语句。
        3.  **核实**: 再次运行 `SELECT * FROM emp;`，找到那五个人，看看他们的工资是不是真的打了七折。
    *   这个案例完美展示了SQL的魅力：你可以把 `SELECT` 中学到的各种高级查询技巧（如 `ORDER BY`, `LIMIT`）和 `UPDATE` 结合起来，实现非常精准和复杂的数据修改。

---

## 1.3 第四节：删除记录 (`DELETE`)

> **一句话概括**：`DELETE` 命令就是你的“删除键”，它会找到你指定的记录，然后把它们从表中彻底抹除，整行消失。

### 1.3.1 核心语法解析

删除的逻辑比更新更简单：“嘿，数据库，你帮我 **从** `这个表里` **删除** 记录，但前提是，你要删除的是 **符合** `这个条件` 的那些记录。”

$$
DELETE FROM 表名 WHERE 条件;
$$

*   `DELETE FROM 表名`: `DELETE FROM` 意思是“从...中删除”。`表名` 指明了要从哪张表中删除数据。
*   `WHERE 条件`: 和 `UPDATE` 一样，`WHERE` 在 `DELETE` 中同样至关重要，它决定了到底要删除哪些记录。如果你想删除'harry'，条件就是 `WHERE name = 'harry'`。

> [!DANGER] **最高级别危险警告：`DELETE` 命令绝对不能忘了 `WHERE`**
> 如果你在 `DELETE` 语句中不写 `WHERE` 条件，比如 `DELETE FROM emp;`，数据库会认为你想删除 **表中的所有记录**！这被称为“删库跑路”的前兆，一旦执行且没有备份，所有数据将灰飞烟灭，后果不堪设想！**在执行任何 `DELETE` 操作前，请再三确认你的 `WHERE` 条件是否正确！**

### 1.3.2 实战案例

*   **目标**: 删除名为 'harry' 的员工记录。
*   **思路**:
    1.  `DELETE FROM emp`: 告诉数据库我们要从 `emp` 表中删除数据。
    2.  `WHERE name = 'harry'`: 精准锁定 `name` 为 'harry' 的那条（或多条）记录。
*   **SQL代码**:
    ```sql
    DELETE FROM emp
    WHERE name = 'harry';
    ```
*   **细节剖析**:
    *   `DELETE` 操作是整行删除。一旦执行，`harry` 这条记录的所有信息（姓名、年龄、薪水、部门等）都会被一并移除。
    *   同样，在执行 `DELETE` 前，强烈建议先用 `SELECT * FROM emp WHERE ...` 加上你将要使用的 `WHERE` 条件，先查询一遍，确保你选中的就是要删除的数据，不多也不少。

好了同学，以上就是对更新和删除操作的超详细拆解。现在你不仅知道了怎么用，还理解了每个部分的来源和需要注意的细节。多动手练习，你很快就能熟练掌握啦！
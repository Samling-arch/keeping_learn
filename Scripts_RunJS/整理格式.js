// JSRun 插件的标准入口
module.exports = async function (params) {
  // 从传入的参数中解构出 app 对象
  const { app } = params;

  const file = app.workspace.getActiveFile();

  if (!file) {
    new Notice("错误：找不到当前文件。", 5000);
    return;
  }

  const originalContent = await app.vault.read(file);
  let newContent = originalContent;

  // AI常见开头语的匹配模式
  // 修正：将所有正则中的 . 替换为 [\s\S] 并移除 /s 标志，以增强兼容性
  const aiStartPatterns = [
    /^好的[，,][\s\S]*?---\s*/,                    // 好的，...
    /^当然[，,][\s\S]*?---\s*/,                    // 当然，...
    /^没问题[，,][\s\S]*?---\s*/,                  // 没问题，...
    /^理解[，,][\s\S]*?---\s*/,                    // 理解，...
    /^明白[，,][\s\S]*?---\s*/,                    // 明白，...
    /^收到[，,][\s\S]*?---\s*/,                    // 收到，...
    /^遵照[\s\S]*?---\s*/,                         // 遵照...
    /^根据[\s\S]*?要求[\s\S]*?---\s*/,              // 根据...要求...
    /^按照[\s\S]*?要求[\s\S]*?---\s*/,              // 按照...要求...
    /^我将[\s\S]*?整理[\s\S]*?---\s*/,              // 我将...整理...
    /^我会[\s\S]*?整理[\s\S]*?---\s*/,              // 我会...整理...
    /^以下是[\s\S]*?整理[\s\S]*?---\s*/,            // 以下是...整理...
    /^为您[\s\S]*?整理[\s\S]*?---\s*/,              // 为您...整理...
    /^帮您[\s\S]*?整理[\s\S]*?---\s*/,              // 帮您...整理...
    /^这里是[\s\S]*?整理[\s\S]*?---\s*/,            // 这里是...整理...
    /^现在[\s\S]*?整理[\s\S]*?---\s*/,              // 现在...整理...
    /^让我[\s\S]*?整理[\s\S]*?---\s*/,              // 让我...整理...
    /^我来[\s\S]*?整理[\s\S]*?---\s*/,              // 我来...整理...
    /^下面是[\s\S]*?---\s*/,                       // 下面是...
    /^以下[\s\S]*?---\s*/,                         // 以下...
    /^这是[\s\S]*?---\s*/,                         // 这是...
    /^这里[\s\S]*?---\s*/,                         // 这里...
    /^根据[\s\S]*?内容[\s\S]*?---\s*/,              // 根据...内容...
    /^基于[\s\S]*?内容[\s\S]*?---\s*/,              // 基于...内容...
    /^针对[\s\S]*?内容[\s\S]*?---\s*/,              // 针对...内容...
    /^关于[\s\S]*?内容[\s\S]*?---\s*/,              // 关于...内容...
    /^为了[\s\S]*?---\s*/,                         // 为了...
    /^Sure[，,][\s\S]*?---\s*/,                    // Sure，...
    /^Of course[，,][\s\S]*?---\s*/,               // Of course，...
    /^Certainly[，,][\s\S]*?---\s*/,               // Certainly，...
    /^I'll[\s\S]*?---\s*/,                         // I'll...
    /^I will[\s\S]*?---\s*/,                       // I will...
    /^Here[\s\S]*?---\s*/,                         // Here...
    /^Based on[\s\S]*?---\s*/,                     // Based on...
    /^According to[\s\S]*?---\s*/,                 // According to...
  ];

  // 尝试匹配并删除AI开头语
  let patternMatched = false;
  for (let pattern of aiStartPatterns) {
    if (pattern.test(newContent)) {
      newContent = newContent.replace(pattern, '');
      patternMatched = true;
      break;
    }
  }

  // 如果没有匹配到预定义模式，使用通用模式
  if (!patternMatched) {
    // 修正：移除 /s 标志，确保兼容性
    newContent = newContent.replace(/^[\s\S]*?---\s*\n*/, '');
  }

  // 格式优化：确保---分隔线上下都有空行
  // 注意：(?<=\S) 这种 "后行断言" 也是较新的语法，但比 /s 标志兼容性稍好。
  // 如果此脚本仍然有问题，可以考虑修改这一行。但通常这一行可以正常工作。
  newContent = newContent.replace(/(?<=\S)\n(^\s*---\s*$)/gm, '\n\n$1');
  newContent = newContent.replace(/(^\s*---\s*$)\n(?=\S)/gm, '$1\n\n');

  // 紧凑排版优化：
  // 1. 合并多余的换行符，最多保留一个空行
  newContent = newContent.replace(/\n{3,}/g, '\n\n');

  // 2. 标题前后的空行优化：标题前保留一个空行，标题后紧跟内容
  newContent = newContent.replace(/\n{2,}(^#+\s)/gm, '\n\n$1');
  newContent = newContent.replace(/(^#+\s.*$)\n{2,}/gm, '$1\n');

  // 3. 列表项之间更紧凑
  newContent = newContent.replace(/(\n- .*)\n\n(?=- )/gm, '$1\n');

  // 4. 段落之间保持适当间距，但不要过多空行
  newContent = newContent.replace(/(?<=\S)\n{2,}(?=\S)/gm, '\n\n');

  // 去除首尾空行
  newContent = newContent.trim();

  // 智能写入
  if (originalContent !== newContent) {
    await app.vault.modify(file, newContent);
    new Notice("笔记已成功清理并调整格式！✨", 3000);
  } else {
    new Notice("笔记格式很完美，无需清理。", 3000);
  }
}

---

### **Python核心数据结构总览 (数据分析视角)**

#### **一、 四大核心数据结构对比**

这张表格是你选择数据结构时的第一决策依据。

| 特性 | 列表 (List) | 元组 (Tuple) | 字典 (Dictionary) | 集合 (Set) |
| :--- | :--- | :--- | :--- | :--- |
| **核心比喻** | 灵活的货架 | 石碑上的记录 | 智能通讯录 | 俱乐部成员名单 |
| **有序性** | **有序** | **有序** | **有序** (3.7+) | **无序** |
| **可变性** | **可变** (Mutable) | **不可变** (Immutable) | **可变** (Mutable) | **可变** (Mutable) |
| **元素唯一性** | 可重复 | 可重复 | **键(Key)唯一** | **元素唯一** |
| **访问方式** | 数字索引 `list[0]` | 数字索引 `tuple[0]` | 键 `dict['key']` | 不支持直接访问 |
| **语法符号** | `[ ]` | `( )` | `{key: value}` | `{}` |

---

#### **二、 各数据结构详解与应用场景**

##### **1. 列表 (List)**
*   **核心特性**：有序、可变、可重复。
*   **核心操作**：通过索引访问 `list[i]`，修改 `list[i] = new_value`，添加 `list.append()`，删除 `list.pop()`。
*   **数据分析场景**：
    *   **存储时序数据**：如每日股票价格、网站DAU等需要保持顺序的数据。
    *   **数据清洗中转站**：作为临时容器，存放和处理从数据源读取后需要修改的数据。
    *   **列表推导式**：用于数据转换和特征工程，极其高效。
*   **一句话总结**：当你需要一个**有序**的元素序列，并且计划在后续**频繁地增、删、改**时，用列表。

##### **2. 元组 (Tuple)**
*   **核心特性**：有序、**不可变**、可重复。
*   **核心操作**：通过索引访问 `tuple[i]`。**不能修改、添加、删除**。
*   **数据分析场景**：
    *   **存储固定记录**：如坐标 `(x, y)`、RGB颜色值 `(r, g, b)` 等不应被改变的数据。
    *   **作为字典的键**：这是元组最重要的特性之一。因为其不可变，所以可以作为字典的键，而列表不行。例如，用 `(省, 市)` 作为键。
    *   **函数返回多个值**：Python函数返回多个值时，会默认打包成一个元组。
*   **一句话总结**：当你需要存储一组**不希望被改变**的有序数据时，尤其是需要把这组数据作为**字典的键**时，用元组。

##### **3. 字典 (Dictionary)**
*   **核心特性**：键-值对(Key-Value)的集合，键必须**唯一且不可变**。
*   **核心操作**：通过键访问 `dict['key']`，修改/添加 `dict['key'] = value`，删除 `dict.pop('key')`，安全访问 `dict.get('key', default)`。
*   **数据分析场景**：
    *   **存储结构化信息**：完美对应JSON格式，用于表示用户配置、API返回结果等。
    *   **频率计数**：统计各项出现的次数，如词频统计。
    *   **数据映射与转换**：将文本标签（如'高','中','低'）映射为数值（如2,1,0），是机器学习预处理的关键步骤。
*   **一句话总结**：当你的数据有**明确的标识符（键）**，并且你需要通过这个标识符**快速查找、修改或添加对应的值**时，用字典。

##### **4. 集合 (Set)**
*   **核心特性**：无序、**元素唯一**。
*   **核心操作**：添加 `set.add()`，删除 `set.remove()`，以及强大的集合运算（交集 `&`，并集 `|`，差集 `-`）。
*   **数据分析场景**：
    *   **快速去重**：将列表转换为集合是最高效的去重方法。
    *   **成员资格测试**：检查一个元素是否存在于一个庞大的数据集中（`element in my_set`），速度远快于列表。
    *   **数据集比较**：分析两组数据的共同用户（交集）、流失用户（差集）、新增用户（差集）等。
*   **一句话总结**：当你的核心需求是**去重**和**高效地比较两组数据**时，用集合。

---

#### **三、 关键概念与代码深度解析**

1.  **列表推导式 (List Comprehension)**
    *   **结构**: `[expression for item in iterable if condition]`
    *   **解读**: “对于 `iterable` 中的每一个 `item`，如果它满足 `condition`，就对它执行 `expression`，然后把所有结果收集到一个新列表里。”
    *   **示例**: `[float(s) for s in temps if s.isdigit()]`
    *   **优点**: 代码简洁、可读性强（对熟练者而言）、执行效率高。

2.  **字典的键：不可变性与哈希 (Immutability & Hashability)**
    *   **核心规则**: 字典的键必须是**不可变**的（因此是**可哈希**的）。
    *   **比喻**: 字典是智能储物柜，键是**钢印**的永久钥匙，值是柜里的物品。列表是**橡皮泥**做的临时钥匙，随时会变，系统不接受。
    *   **为什么**: 字典依赖哈希算法实现快速查找。可变对象（如列表）的哈希值会变，导致系统崩溃。
    *   **实践**: `('广东', '深圳')` 可以做键，`['广东', '深圳']` **不行**，会报 `TypeError: unhashable type: 'list'`。

3.  **字典的查找与映射：`dict[key]`**
    *   **含义**: 这是字典最核心的操作，意为“**查找**”。
    *   **比喻**: `risk_map[label]` 就是拿着 `label` 这个名字，去 `risk_map` 这个通讯录里查找对应的电话号码。
    *   **应用**: 在数据映射中，它高效地将一个列表中的每个原始值“翻译”成字典中定义的目标值。

4.  **文本分割：`split()` vs. 中文分词**
    *   **`text.split()`**: 适用于英文等有**明确分隔符**（如空格）的语言。它是一个简单的机械切割操作。
    *   **中文分词 (如 `jieba.cut()`)**: 适用于中文等词语间**无分隔符**的语言。它是一个基于词典和算法的**语义理解**过程。
    *   **关键差异**: 一个是机械操作，一个是智能分析。在处理中文文本时，必须使用专业的分词库。

---

#### **四、 如何选择：一个简单的决策流程**

当你面对一个数据处理任务时，可以这样问自己：

1.  **我需要存储“键-值”对吗？（比如，用学号查姓名）**
    *   **是** -> 使用 **字典 (Dictionary)**。

2.  **(如果不是键值对) 我需要处理的是一系列元素。那么，我的主要目的是去重，或者比较两组元素的关系吗？**
    *   **是** -> 使用 **集合 (Set)**。

3.  **(如果也不是去重) 我需要一个有序的元素序列。那么，这个序列在创建之后需要被修改（增、删、改）吗？**
    *   **不需要** (数据是固定的，如坐标、函数返回值) -> 使用 **元组 (Tuple)**。它更安全、高效，且能作为字典的键。
    *   **需要** (数据在处理过程中会变化，如临时列表) -> 使用 **列表 (List)**。

这份清单涵盖了我们讨论的所有要点，希望能帮助你建立一个清晰、系统的知识框架。